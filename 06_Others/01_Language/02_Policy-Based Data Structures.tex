\paragraph{红黑树}
\subparagraph{声明/头文件}
\begin{lstlisting}
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
typedef tree<pt, null_type, less<pt>, rb_tree_tag, tree_order_statistics_node_update> rbtree;
\end{lstlisting}
\subparagraph{使用方法}
\begin{lstlisting}
pt                                 // 关键字类型
null_type                          // 无映射(低版本g++为null_mapped_type)
less<int>                          // 从小到大排序
rb_tree_tag                        // 红黑树（splay_tree_tag）
tree_order_statistics_node_update  // 结点更新
T.insert(val);                     // 插入
T.erase(iterator);                 // 删除
T.order_of_key();                  // 查找有多少数比它小
T.find_by_order(k);                // 有k个数比它小的数是多少
a.join(b);                         // b并入a 前提是两棵树的key的取值范围不相交
a.split(v, b);                     // key小于等于v的元素属于a，其余的属于b
T.lower_bound(x);                  // >=x的min的迭代器
T.upper_bound((x);                 // >x的min的迭代器
\end{lstlisting}
\paragraph{可并堆}
\subparagraph{声明/头文件}
\begin{lstlisting}
#include <ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;
typedef __gnu_pbds::priority_queue <int, greater<int>, pairing_heap_tag> Heap;
\end{lstlisting}
\subparagraph{使用方法}
\begin{lstlisting}
erase(iterator) 根据迭代器删除元素
modify(iterator, val) 根据迭代器修改值
join(other), 使用之后另一个会被清空
其他同STL
\end{lstlisting}
\paragraph{可持久化平衡树}
\subparagraph{声明/头文件}
\begin{lstlisting}
#include <ext/rope>
using namespace __gnu_cxx;
\end{lstlisting}
\subparagraph{使用方法}
\begin{lstlisting}
下标从0开始，不可以cin，可以cout
由于rope的底层实现，insert，erase，get都是logn的
reverse是O(n)的，所以构造两个rope来做
push_back(x)    在末尾添加x
insert(pos,x)   在pos插入x
erase(pos,x)    从pos开始删除x个
replace(pos,x)  从pos开始换成x
substr(pos,x)   提取pos开始x个
at(x)/[x]   访问第x个元素
rope<int>*his[maxn], his[i]=new rope<char>(*his[i-1]) 可持久化数组
\end{lstlisting}